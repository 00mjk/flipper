(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{130:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return h}));var i=t(0),a=t.n(i);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=a.a.createContext({}),c=function(e){var n=a.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},u=function(e){var n=c(e.components);return a.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},b=Object(i.forwardRef)((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=c(t),b=i,h=u["".concat(l,".").concat(b)]||u[b]||d[b]||r;return t?a.a.createElement(h,o({ref:n},s,{components:t})):a.a.createElement(h,o({ref:n},s))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=b;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},131:function(e,n,t){"use strict";t.d(n,"b",(function(){return r})),t.d(n,"a",(function(){return l}));var i=t(133),a=t(132);function r(){var e=Object(i.a)().siteConfig,n=(e=void 0===e?{}:e).baseUrl,t=void 0===n?"/":n,r=e.url;return{withBaseUrl:function(e,n){return function(e,n,t,i){var r=void 0===i?{}:i,l=r.forcePrependBaseUrl,o=void 0!==l&&l,p=r.absolute,s=void 0!==p&&p;if(!t)return t;if(t.startsWith("#"))return t;if(Object(a.b)(t))return t;if(o)return n+t;var c=!t.startsWith(n)?n+t.replace(/^\//,""):t;return s?e+c:c}(r,t,e,n)}}}function l(e,n){return void 0===n&&(n={}),(0,r().withBaseUrl)(e,n)}},132:function(e,n,t){"use strict";function i(e){return!0===/^(\w*:|\/\/)/.test(e)}function a(e){return void 0!==e&&!i(e)}t.d(n,"b",(function(){return i})),t.d(n,"a",(function(){return a}))},133:function(e,n,t){"use strict";var i=t(0),a=t(19);n.a=function(){var e=Object(i.useContext)(a.a);if(null===e)throw new Error("Docusaurus context not provided");return e}},81:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return p})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return u}));var i=t(2),a=t(6),r=(t(0),t(130)),l=t(131),o={id:"desktop-plugins",title:"Creating Desktop Plugin (Sandy)"},p={unversionedId:"extending/desktop-plugins",id:"extending/desktop-plugins",isDocsHomePage:!1,title:"Creating Desktop Plugin (Sandy)",description:"What is new in Sandy plugins?",source:"@site/../docs/extending/desktop-plugins.mdx",permalink:"/docs/extending/desktop-plugins",editUrl:"https://github.com/facebook/flipper/blob/master/website/../docs/extending/desktop-plugins.mdx",sidebar:"extending",previous:{title:"Debugging",permalink:"/docs/extending/debugging"},next:{title:"flipper-plugin API reference (Sandy)",permalink:"/docs/extending/flipper-plugin"}},s=[{value:"What is new in Sandy plugins?",id:"what-is-new-in-sandy-plugins",children:[]},{value:"Opting in to Sandy",id:"opting-in-to-sandy",children:[]},{value:"Anatomy of Sandy plugin",id:"anatomy-of-sandy-plugin",children:[{value:"Creating a Device Plugin",id:"creating-a-device-plugin",children:[]}]},{value:"Creating a first plugin",id:"creating-a-first-plugin",children:[]},{value:"The <code>plugin</code> declaration",id:"the-plugin-declaration",children:[]},{value:"Writing <code>plugin</code> logic",id:"writing-plugin-logic",children:[{value:"Testing <code>plugin</code> logic",id:"testing-plugin-logic",children:[]}]},{value:"Building a User Interface for the plugin",id:"building-a-user-interface-for-the-plugin",children:[{value:"Unit testing the User Interface",id:"unit-testing-the-user-interface",children:[]}]},{value:"Conclusion",id:"conclusion",children:[]}],c={rightToc:s};function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"what-is-new-in-sandy-plugins"},"What is new in Sandy plugins?"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"(This section is only relevant if you authored Flipper plugins before)")),Object(r.b)("p",null,'"Sandy" is the new standard for writing Flipper Desktop plugins.\nIt is a fresh way of writing plugins that comes in two parts:'),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"New plugin APIs and a simplified plugin life-cycle"),Object(r.b)("li",{parentName:"ol"},"A standardized component library based on ",Object(r.b)("a",Object(i.a)({parentName:"li"},{href:"https://ant.design/"}),"Ant Design")," ","[TBD]")),Object(r.b)("p",null,"The Sandy plan, goals and timelines are described in detail in this ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://fb.quip.com/YHOGAnaPqAVJ"}),"quip")," ","[FB-only]",".\nBut the high-level goal is to improve reliability, consistency and maintainability of Flipper plugins.\nIt offers the following benefits to plugin authors:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Sandy plugins decouple the plugin state, logic and life-cycle from the UI life-cycle, which simplifies testing, and makes it trivial to maintain state over time."),Object(r.b)("li",{parentName:"ul"},"Sandy is designed with a testing-first approach in mind. It allows mocking all Device / Client \u27f7 Plugin interactions."),Object(r.b)("li",{parentName:"ul"},"By leveraging Ant Design, all components are well documented, discoverable and consistent, leading to a much better user- and developer experience."),Object(r.b)("li",{parentName:"ul"},"Sandy plugins can be tested stand-alone, which is currently not the case for OSS plugins."),Object(r.b)("li",{parentName:"ul"},"Sandy plugins are entirely strongly typed, and generally offer one-way of doing things, unlike the current APIs."),Object(r.b)("li",{parentName:"ul"},"Sandy will be compatible with concurrent React."),Object(r.b)("li",{parentName:"ul"},"Sandy will make very common scenarios trivial, such as showing an append-only event log."),Object(r.b)("li",{parentName:"ul"},"Sandy fixes several performance bottlenecks that are rooted in our current API design.")),Object(r.b)("h2",{id:"opting-in-to-sandy"},"Opting in to Sandy"),Object(r.b)("p",null,"Since Sandy is still experimental, the public and FB plugin scaffolding tools still use the old APIs.\nYou can opt-in to using Sandy by adding ",Object(r.b)("inlineCode",{parentName:"p"},"flipper-plugin")," as peer dependency to your plugin."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"yarn add --peer flipper-plugin")),Object(r.b)("p",null,"If your project is not hosted inside the Flipper project itself, you need to add ",Object(r.b)("inlineCode",{parentName:"p"},"flipper-plugin")," as developer dependency as well:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"yarn add --dev flipper-plugin")),Object(r.b)("h2",{id:"anatomy-of-sandy-plugin"},"Anatomy of Sandy plugin"),Object(r.b)("p",null,"A sandy plugin always exposes two elements from its entry module (typically ",Object(r.b)("inlineCode",{parentName:"p"},"src/index.tsx"),"): ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Component"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),"import {PluginClient} from 'flipper-plugin';\n\nexport function plugin(client: PluginClient) {\n  return {}; // API exposed from this plugin\n}\n\nexport function Component() {\n  // Plugin UI\n  return <h1>Welcome to my first plugin</h1>;\n}\n")),Object(r.b)("p",null,"The concepts of ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Component")," are explained below. Note that these names have to be exact!"),Object(r.b)("h3",{id:"creating-a-device-plugin"},"Creating a Device Plugin"),Object(r.b)("p",null,"Flipper also supports so-called device plugins - plugins that are available for an entire device - but don't receive a connection to a running app,\nso are a bit more limited in general.\nTheir entry module anatomy is:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),"import {DevicePluginClient} from 'flipper-plugin';\n\nexport function supportsDevice(device: Device) {\n  // based on the device meta-data, \n  // determine whether this plugin should be enabled \n  return true; \n}\n\nexport function devicePlugin(client: DevicePluginClient) {\n  return {}; // API exposed from this plugin\n}\n\nexport function Component() {\n  // Plugin UI\n  return <h1>Welcome to my first plugin</h1>;\n}\n")),Object(r.b)("p",null,"Device plugins work in general similar to normal client plugins, so aren't worked out in detail in this document.\nThe available APIs for device plugins are listed ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"./flipper-plugin#devicepluginclient"}),"here"),"."),Object(r.b)("h2",{id:"creating-a-first-plugin"},"Creating a first plugin"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"This tutorial is analogous to the original ",Object(r.b)("a",Object(i.a)({parentName:"em"},{href:"../tutorial/js-setup"}),"Building a Desktop Plugin tutorial"),", and the plugin scaffolding and loading steps from that tutorial should be followed first")),Object(r.b)("p",null,"The sea-mammals plugin is a minimal plugin that shows some data fetched from the ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"../tutorial/ios"}),"Tutorial application"),".\nThe end-state of our plugin can be found in the ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/facebook/flipper/tree/master/desktop/plugins/seamammals"}),"Github Repo"),"."),Object(r.b)("img",{alt:"Custom cards UI for our sea mammals plugin",src:Object(l.a)("img/js-custom.png")}),Object(r.b)("p",null,"Let's start by setting up our plugin initialization. We update the earlier generated ",Object(r.b)("inlineCode",{parentName:"p"},"index.tsx")," to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),"import React from 'react';\nimport {PluginClient, createState} from 'flipper-plugin';\n\n// (3)\ntype Row = {\n  id: number;\n  title: string;\n  url: string;\n};\n\n// (2)\ntype Events = {\n  newRow: Row;\n};\n\n// (1)\nexport function plugin(client: PluginClient<Events, {}>) {\n  // (5)\n  const rows = createState<Record<string, Row>>({}, {persist: 'rows'});\n  const selectedID = createState<string | null>(null, {persist: 'selection'});\n\n  // (6)\n  client.onMessage('newRow', (row) => {\n    rows.update((draft) => {\n      draft[row.id] = row;\n    });\n  });\n\n  // (7)\n  function setSelection(id: number) {\n    selectedID.set('' + id);\n  }\n\n  // (4)\n  return {\n    rows,\n    selectedID,\n    setSelection,\n  };\n}\n\nexport function Component() {\n  return <h1>Sea Mammals plugin</h1>;\n}\n")),Object(r.b)("h2",{id:"the-plugin-declaration"},"The ",Object(r.b)("inlineCode",{parentName:"h2"},"plugin")," declaration"),Object(r.b)("p",null,"The implementation of our plugin is driven by the named, exported function ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," as defined at ",Object(r.b)("inlineCode",{parentName:"p"},"(3)"),".\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," method is called upon instantiating the plugin.\nThat is, whenever a client that uses this plugin connects to Flipper, ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," will be called, if the user has the plugin enabled.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," method receives one argument, the ",Object(r.b)("inlineCode",{parentName:"p"},"client"),", which provides all APIs needed to both interact with Flipper desktop,\nand the plugin loaded into the client application.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"PluginClient")," types all available APIs and takes two generic arguments. "),Object(r.b)("p",null,"The first, ",Object(r.b)("inlineCode",{parentName:"p"},"Events"),", describes all possible events that can be sent from the client plugin to the desktop plugin,\nand determines the events available for ",Object(r.b)("inlineCode",{parentName:"p"},"client.onMessage")," (see below).\nIn our example, only one event can occur, ",Object(r.b)("inlineCode",{parentName:"p"},"newRow"),", as defined at ",Object(r.b)("inlineCode",{parentName:"p"},"(2)"),".\nBut typically there are more.\nThe data provided by this ",Object(r.b)("inlineCode",{parentName:"p"},"newRow")," event is described with the ",Object(r.b)("inlineCode",{parentName:"p"},"Row")," type, as defined at ",Object(r.b)("inlineCode",{parentName:"p"},"(3)"),".\nThe event names and data structures should correspond with the data that is send using ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"../extending/create-plugin#push-data-to-the-desktop"}),Object(r.b)("inlineCode",{parentName:"a"},"connection.send"))," from the client."),Object(r.b)("p",null,"The second generic argument to ",Object(r.b)("inlineCode",{parentName:"p"},"PluginClient")," is typically called ",Object(r.b)("inlineCode",{parentName:"p"},"Methods"),", and describes the methods exposed by the client plugin,\nwhich we can call directly from the desktop plugin.\nThese methods take zero or one argument, and return a Promise.\nThe name, argument and return type should correspond to the data structures we handle in ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"../extending/create-plugin#using-flipperconnection"}),Object(r.b)("inlineCode",{parentName:"a"},"connection.receive"))," in the client plugin.\nIn our example plugin, we aren't supporting any methods so the second generic of ",Object(r.b)("inlineCode",{parentName:"p"},"PluginClient")," is left empty: ",Object(r.b)("inlineCode",{parentName:"p"},"{}"),"."),Object(r.b)("p",null,"From our ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," function, as shown at ",Object(r.b)("inlineCode",{parentName:"p"},"(4)"),", we have to return an object that captures the entire API we want to expose from our plugin to our UI components and unit tests.\nIn this case, we return the state atoms ",Object(r.b)("inlineCode",{parentName:"p"},"rows")," and ",Object(r.b)("inlineCode",{parentName:"p"},"selectedID"),", and expose the ",Object(r.b)("inlineCode",{parentName:"p"},"setSelection")," method."),Object(r.b)("h2",{id:"writing-plugin-logic"},"Writing ",Object(r.b)("inlineCode",{parentName:"h2"},"plugin")," logic"),Object(r.b)("p",null,"Since the ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," function will execute only once during the entire life-cycle of the plugin, we can use local variables in the function body to preserve state.\nIn our example, we create two pieces of state, the set of rows available, ",Object(r.b)("inlineCode",{parentName:"p"},"rows"),", and the current selection: ",Object(r.b)("inlineCode",{parentName:"p"},"selectionID"),". See ",Object(r.b)("inlineCode",{parentName:"p"},"(5)"),"."),Object(r.b)("p",null,"It is possible to store state directly in ",Object(r.b)("inlineCode",{parentName:"p"},"let")," declarations, but ",Object(r.b)("inlineCode",{parentName:"p"},"createState")," creates a storage container that gives us a few advantages.\nMost importantly, state created using ",Object(r.b)("inlineCode",{parentName:"p"},"createState")," can be subscribed to by our UI components using ",Object(r.b)("inlineCode",{parentName:"p"},"useValue"),", as explained below.\nSecondly, state created with ",Object(r.b)("inlineCode",{parentName:"p"},"createState")," can be made part of Flipper imports / exports.\nWe can enable this feature by providing a unique ",Object(r.b)("inlineCode",{parentName:"p"},"persist")," key.\nThe current value of a the container can be read using ",Object(r.b)("inlineCode",{parentName:"p"},".get()"),", and ",Object(r.b)("inlineCode",{parentName:"p"},".set()")," or ",Object(r.b)("inlineCode",{parentName:"p"},".update()")," can be used to replace the current value."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"client")," can be used to receive and send information to the client plugin.\nWith ",Object(r.b)("inlineCode",{parentName:"p"},"client.send"),", we can invoke methods on the plugin.\nWith ",Object(r.b)("inlineCode",{parentName:"p"},"client.onMessage")," (",Object(r.b)("inlineCode",{parentName:"p"},"(6)"),") we can subscribe to the specific events as specified with the ",Object(r.b)("inlineCode",{parentName:"p"},"Events")," type (",Object(r.b)("inlineCode",{parentName:"p"},"(2)"),").\nIn the event handler, we can update some pieces of state, using the ",Object(r.b)("inlineCode",{parentName:"p"},".set")," method to replace state, or the ",Object(r.b)("inlineCode",{parentName:"p"},".update")," method to immutably update the state using ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://immerjs.github.io/immer"}),"immer"),".",Object(r.b)("br",{parentName:"p"}),"\n","In this case, we add the received row to the ",Object(r.b)("inlineCode",{parentName:"p"},"rows")," state under its own ",Object(r.b)("inlineCode",{parentName:"p"},"id"),"."),Object(r.b)("p",null,"Finally, ",Object(r.b)("inlineCode",{parentName:"p"},"(7)"),", we create (and expose at ",Object(r.b)("inlineCode",{parentName:"p"},"(4)"),") a utility to update the selection, which we will user later in our UI."),Object(r.b)("p",null,"Note that no state should be stored outside the ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," definition; multiple invocations of ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," can be 'alive' if multiple connected apps are using the plugin.\nStoring the state inside the closure makes sure no state is mixed up."),Object(r.b)("h3",{id:"testing-plugin-logic"},"Testing ",Object(r.b)("inlineCode",{parentName:"h3"},"plugin")," logic"),Object(r.b)("p",null,"Before we create the UI for our plugin, we are going to pretend that we always write unit tests first.\nUnit tests will be picked automatically by Jest if they are named like ",Object(r.b)("inlineCode",{parentName:"p"},"__tests__/*.spec.tsx"),", so we create a file called ",Object(r.b)("inlineCode",{parentName:"p"},"__tests__/seamammals.spec.tsx")," and start the test runner by\nrunning ",Object(r.b)("inlineCode",{parentName:"p"},"yarn test --watch")," in our plugin root.\nHere is our initial unit test:"),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),'// (1)\nimport {TestUtils} from \'flipper-plugin\';\n// (2)\nimport * as MammalsPlugin from \'..\';\n\ntest(\'It can store rows\', () => {\n  // (3)\n  const {instance, sendEvent} = TestUtils.startPlugin(MammalsPlugin);\n\n  expect(instance.rows.get()).toEqual({});\n  expect(instance.selectedID.get()).toBeNull();\n\n  // (4)\n  sendEvent(\'newRow\', {\n    id: 1,\n    title: \'Dolphin\',\n    url: \'http://dolphin.png\',\n  });\n  sendEvent(\'newRow\', {\n    id: 2,\n    title: \'Turtle\',\n    url: \'http://turtle.png\',\n  });\n\n  // (5)\n  expect(instance.rows.get()).toMatchInlineSnapshot(`\n    Object {\n      "1": Object {\n        "id": 1,\n        "title": "Dolphin",\n        "url": "http://dolphin.png",\n      },\n      "2": Object {\n        "id": 2,\n        "title": "Turtle",\n        "url": "http://turtle.png",\n      },\n    }\n  `);\n});\n')),Object(r.b)("p",null,"Testing utilities for plugins are shipped as part of ",Object(r.b)("inlineCode",{parentName:"p"},"flipper-plugin"),", so we import them (",Object(r.b)("inlineCode",{parentName:"p"},"(1)"),").\nSecondly, we directly import our above plugin implementation into our unit test.\nUsing ",Object(r.b)("inlineCode",{parentName:"p"},"as"),", we put the entire implementation into one object, which is the format in which our utilities expect them (",Object(r.b)("inlineCode",{parentName:"p"},"(2)"),")."),Object(r.b)("p",null,"Using ",Object(r.b)("inlineCode",{parentName:"p"},"TestUtils.startPlugin")," (",Object(r.b)("inlineCode",{parentName:"p"},"(3)"),") we can instantiate our plugin in a fully mocked environment,\nin which our plugin can do everything except for actually rendering, which makes this operation really cheap.\nFrom the ",Object(r.b)("inlineCode",{parentName:"p"},"startPlugin"),", we get back an ",Object(r.b)("inlineCode",{parentName:"p"},"instance"),", which corresponds to the object we returned from our ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," implementation (",Object(r.b)("inlineCode",{parentName:"p"},"(4)")," in our previous listing).\nBeyond that, we get a bunch of utilities to interact with our plugin.\nThe full list is documented ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"./flipper-plugin#the-test-runner-object"}),"here"),", but for this test we are only interested in ",Object(r.b)("inlineCode",{parentName:"p"},"sendEvent"),"."),Object(r.b)("p",null,"Using ",Object(r.b)("inlineCode",{parentName:"p"},"sendEvent"),", we can mimic the client plugin sending events to our plugin ",Object(r.b)("inlineCode",{parentName:"p"},"(4)"),".\nSimilarly we can emulate all other possible events, such as the initial connection setup with (",Object(r.b)("inlineCode",{parentName:"p"},".connect()"),"), the user (de)selecting the plugin (",Object(r.b)("inlineCode",{parentName:"p"},".activate()")," / ",Object(r.b)("inlineCode",{parentName:"p"},"deactivate()"),"), or a deeplink being triggered (",Object(r.b)("inlineCode",{parentName:"p"},".triggerDeepLink"),") etc."),Object(r.b)("p",null,"After the events have been sent, the internal state of our plugin should have been updated, so we assert this is the case at ",Object(r.b)("inlineCode",{parentName:"p"},"(5)"),".\nThe assertions are provided by ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://jestjs.io/"}),"Jest"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"toMatchInlineSnapshot")," is particularly useful, as it will generate the initial snapshot during the first run of the unit tests, which saves a lot of effort."),Object(r.b)("h2",{id:"building-a-user-interface-for-the-plugin"},"Building a User Interface for the plugin"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"For now, the plugin implementation as shown here uses the old Flipper component library, expect nicer components in the future.")),Object(r.b)("p",null,"So far, in ",Object(r.b)("inlineCode",{parentName:"p"},"index.tsx"),", our ",Object(r.b)("inlineCode",{parentName:"p"},"Component")," didn't do anything useful yet. Time to build some nice UI."),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),'import {usePlugin, useValue} from "flipper-plugin";\n\n// (1)\nexport function Component() {\n  // (2)\n  const instance = usePlugin(plugin);\n  // (3)\n  const rows = useValue(instance.rows);\n  const selectedID = useValue(instance.selectedID);\n\n  // (4)\n  return (\n    <Container>\n      {Object.entries(rows).map(([id, row]) => (\n        <Card\n          row={row}\n          onSelect={instance.setSelection}\n          selected={id === selectedID}\n          key={id}\n        />\n      ))}\n      <DetailSidebar>\n        {selectedID && renderSidebar(rows[selectedID])}\n      </DetailSidebar>\n    </Container>\n  );\n}\n')),Object(r.b)("p",null,"A plugin module can have many components, but it should always export one component named ",Object(r.b)("inlineCode",{parentName:"p"},"Component")," that is used as the root component for the plugin rendering.\nThe component mustn't take any props, and will be mounted by Flipper when the user selects the plugin (",Object(r.b)("inlineCode",{parentName:"p"},"(1)"),")."),Object(r.b)("p",null,"Inside the component we can grab the relevant instance of the plugin by using the ",Object(r.b)("inlineCode",{parentName:"p"},"usePlugin")," (",Object(r.b)("inlineCode",{parentName:"p"},"(2)"),") hook.\nThis returns the instance API we returned in the first listing at the end of the ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," function.\nOur original ",Object(r.b)("inlineCode",{parentName:"p"},"plugin")," definition is passed to the ",Object(r.b)("inlineCode",{parentName:"p"},"usePlugin")," as argument.\nThis is done to get the typings of ",Object(r.b)("inlineCode",{parentName:"p"},"instance")," correct and should always be done."),Object(r.b)("p",null,"With the ",Object(r.b)("inlineCode",{parentName:"p"},"useValue")," hook (",Object(r.b)("inlineCode",{parentName:"p"},"(3)"),"), we can grab the current value from the states we created earlier using ",Object(r.b)("inlineCode",{parentName:"p"},"createState"),".\nThe benefit of ",Object(r.b)("inlineCode",{parentName:"p"},"useValue(instance.rows)")," over using ",Object(r.b)("inlineCode",{parentName:"p"},"rows.get()"),", is that the first will automatically subscribe our component to any future updates to the state, causing the component to re-render when new rows arrive."),Object(r.b)("p",null,"Since both ",Object(r.b)("inlineCode",{parentName:"p"},"usePlugin")," and ",Object(r.b)("inlineCode",{parentName:"p"},"useValue")," are hooks, they usual React rules for them apply; they need to be called unconditionally.\nSo it is recommended to put them at the top of your component body.\nBoth hooks can not only be used in the root ",Object(r.b)("inlineCode",{parentName:"p"},"Component"),", but also in any other component in your plugin component tree.\nSo it is not necessary to grab all the data at the root, or pass down the ",Object(r.b)("inlineCode",{parentName:"p"},"instance")," to all child components. "),Object(r.b)("p",null,"Finally (",Object(r.b)("inlineCode",{parentName:"p"},"(4)"),") we render the data we have. The details have been left out here, as from here it is just idiomatic React code.\nThe source of the other components can be found ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://github.com/facebook/flipper/blob/95ae98d925e27e1c9ce0706e3c7ded78eba7c13c/desktop/plugins/seamammals/src/index.tsx#L113-L165"}),"here"),"."),Object(r.b)("h3",{id:"unit-testing-the-user-interface"},"Unit testing the User Interface"),Object(r.b)("p",null,"At this moment the plugin is ready to be used in Flipper, and opening it should lead to sane results.\nBut let's verify with some tests that the UI works correctly, and doesn't regress in the future by adding another unit test to the ",Object(r.b)("inlineCode",{parentName:"p"},"seamammals.spec.tsx")," file and assert that the rendering is correct and interactive:"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note: until the new component library is standardized, some additional mocks that are left out here are needed as shown in the ",Object(r.b)("a",Object(i.a)({parentName:"em"},{href:"https://github.com/facebook/flipper/blob/a994683b2ecc602e9a7aff18fb72d552c6893283/desktop/plugins/seamammals/src/__tests__/seammammals.node.tsx#L15-L37"}),"real test implementation"))),Object(r.b)("pre",null,Object(r.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript"}),"test('It can have selection and render details', async () => {\n  // (1)\n  const {\n    instance,\n    renderer,\n    act,\n    sendEvent,\n    exportState,\n  } = TestUtils.renderPlugin(MammalsPlugin);\n\n  // (2)\n  sendEvent('newRow', {\n    id: 1,\n    title: 'Dolphin',\n    url: 'http://dolphin.png',\n  });\n  sendEvent('newRow', {\n    id: 2,\n    title: 'Turtle',\n    url: 'http://turtle.png',\n  });\n\n  // (3) Dolphin card should now be visible\n  expect(await renderer.findByTestId('Dolphin')).not.toBeNull();\n  // (4) Let's assert the structure of the Turtle card as well\n  expect(await renderer.findByTestId('Turtle')).toMatchInlineSnapshot(`\n    <div\n      class=\"css-ok7d66-View-FlexBox-FlexColumn\"\n      data-testid=\"Turtle\"\n    >\n      <div\n        class=\"css-vgz97s\"\n        style=\"background-image: url(http://turtle.png);\"\n      />\n      <span\n        class=\"css-8j2gzl-Text\"\n      >\n        Turtle\n      </span>\n    </div>\n  `);\n\n  // (5) Nothing selected, so we should not have a sidebar\n  expect(renderer.queryAllByText('Extras').length).toBe(0);\n\n  act(() => {\n    instance.setSelection(2);\n  });\n\n  // Sidebar should be visible now\n  expect(await renderer.findByText('Extras')).not.toBeNull();\n\n  // (6) Verify export\n  expect(exportState()).toEqual({\n    rows: {\n      '1': {\n        id: 1,\n        title: 'Dolphin',\n        url: 'http://dolphin.png',\n      },\n      '2': {\n        id: 2,\n        title: 'Turtle',\n        url: 'http://turtle.png',\n      },\n    },\n    selection: '2',\n  });\n});\n")),Object(r.b)("p",null,"Like in our previous test, we use ",Object(r.b)("inlineCode",{parentName:"p"},"TestUtils")," to start our plugin.\nBut rather than using ",Object(r.b)("inlineCode",{parentName:"p"},"startPlugin"),", we now use ",Object(r.b)("inlineCode",{parentName:"p"},"renderPlugin"),".\nWhich does the same but also renders the component in memory, using ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://testing-library.com/docs/react-testing-library/intro"}),"react-testing-library"),".\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"renderer")," returned by ",Object(r.b)("inlineCode",{parentName:"p"},"startPlugin")," allows us to interact with the DOM."),Object(r.b)("p",null,"Like in the previous test, we start by sending some events to the plugin (",Object(r.b)("inlineCode",{parentName:"p"},"(2)"),").\nAfter that (",Object(r.b)("inlineCode",{parentName:"p"},"(3)"),"), our new data should be reflected in the dom.\nSince we used ",Object(r.b)("inlineCode",{parentName:"p"},"<CardContainer data-testid={row.title}")," in our ",Object(r.b)("inlineCode",{parentName:"p"},"Card")," component implementation (not shown above) we can search in the DOM based on that test-id to find the right element.\nBut it is also possible to search for a specific test etc.\nThe available queries are documented ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://testing-library.com/docs/dom-testing-library/api-queries#queries"}),"here"),"."),Object(r.b)("p",null,"Rather than just checking that the rendering isn't ",Object(r.b)("inlineCode",{parentName:"p"},"null"),", we can also take a snapshot of the DOM, and assert that it doesn't change accidentally in the future.\nJest's ",Object(r.b)("inlineCode",{parentName:"p"},"toMatchInlineSnapshot")," (",Object(r.b)("inlineCode",{parentName:"p"},"(4)"),") is quite useful for that.\nBut don't overuse it as large snapshots are pretty useless and just create a maintenance burden without catching much."),Object(r.b)("p",null,"In the next section, ",Object(r.b)("inlineCode",{parentName:"p"},"(5)"),", we simulate updating the selection from code, and assert that the sidebar has become visible. Note that the update is wrapped in ",Object(r.b)("inlineCode",{parentName:"p"},"act"),", which is recommended as it makes sure that updates are flushed to the DOM before we make queries and assertions on the DOM (the earlier ",Object(r.b)("inlineCode",{parentName:"p"},"sendEvent")," does apply ",Object(r.b)("inlineCode",{parentName:"p"},"act")," automatically and doesn't need wrapping)."),Object(r.b)("p",null,"Alternatively, we could have emulated actually clicking a DOM element, by using ",Object(r.b)("inlineCode",{parentName:"p"},"fireEvent.click(renderer.findByTestId('dolphin'))"),". See ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://testing-library.com/docs/dom-testing-library/api-events"}),"firing events")," in the docs of React testing library for details."),Object(r.b)("p",null,"Finally (",Object(r.b)("inlineCode",{parentName:"p"},"(6)"),") we grab the final state of our plugin state by using the ",Object(r.b)("inlineCode",{parentName:"p"},"exportState")," utility.\nIt returns all the persistable state of our plugin, based on the ",Object(r.b)("inlineCode",{parentName:"p"},"persist")," keys we passed to ",Object(r.b)("inlineCode",{parentName:"p"},"createState")," in our first listing.\nWe can now assert that the plugin ends up in the desired state."),Object(r.b)("h2",{id:"conclusion"},"Conclusion"),Object(r.b)("p",null,"That concludes the Sandy Desktop plugin tutorial.\nThe takeaway here is that logic and UI are very strictly separated in Sandy plugins,\nmaking them very suitable for test-driven development.\nBeyond that, the new plugin model enables the state of the plugin to be preserved even when it is not currently shown in the UI, simplifying the state and event processing logic."),Object(r.b)("p",null,"The complete Sandy APIs are fleshed out in the ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/extending/flipper-plugin"}),"Flipper-plugin API Reference"),"."))}u.isMDXComponent=!0}}]);